[gd_scene load_steps=3 format=3 uid="uid://dh0d4awljrbsi"]

[sub_resource type="GDScript" id="GDScript_qphse"]
resource_name = "example"
script/source = "extends Node

@export var http: AwaitableHTTPRequest


func _ready() -> void:
	print(\"Example 1: JSON API\")
	var data := await request_api()
	if not data.is_empty():
		var user := data[\"login\"] as String
		print(\"User: \", user)

	print(\"\\nExample 2: Downloading an image\")
	var bytes := await request_image()
	if not bytes.is_empty():
		# Snippet for loading a PackedByteArray into an Image,
		# as well as an ImageTexture to use in your app/game.
		#var img := Image.new()
		#img.load_png_from_buffer(bytes)
		#var tex := ImageTexture.create_from_image(img)

		var path := OS.get_system_dir(OS.SYSTEM_DIR_DOWNLOADS)+\"/image.png\"
		var file := FileAccess.open(path, FileAccess.WRITE)
		if not file:
			push_error(\"Failed to save image.\")
			return

		file.store_buffer(bytes)
		print(\"Downloaded and saved a random image to %s, take a look!\" % path)


#region Example 1: JSON API
func request_api() -> Dictionary:
	var resp := await http.async_request(
		\"https://api.github.com/users/swarkin\",
		PackedStringArray([ # headers
			\"accept: application/vnd.github+json\",
			\"user-agent: Swarkin/AwaitableHTTPRequest/2.2.0\",
		]),
	)

	if !resp.success() or resp.status_err():
		push_error(\"Request failed.\")
		return {}

	print(\"Status code: \", resp.status)
	print(\"Content-Type:\", resp.headers[\"content-type\"])

	var json := resp.body_as_json()
	if not json:
		push_error(\"JSON invalid.\")
		return {}

	return json as Dictionary
#endregion

#region Example 2: Downloading an image
func request_image() -> PackedByteArray:
	var resp := await http.async_request(\"https://picsum.photos/256\")
	if !resp.success() or resp.status_err():
		push_error(\"Request failed.\")
		return PackedByteArray()

	return resp.bytes
#endregion
"

[sub_resource type="GDScript" id="GDScript_2i6dy"]
script/source = "class_name AwaitableHTTPRequest
extends HTTPRequest
## [img width=64]res://addons/awaitable_http_request/icon.png[/img]   [url=https://github.com/Swarkin/Godot-AwaitableHTTPRequest]AwaitableHTTPRequest[/url] 2.2.0 by Swarkin & [url=https://github.com/Swarkin/Godot-AwaitableHTTPRequest/graphs/contributors]contributors[/url].
# View the formatted documentation in Godot by pressing F1 and typing \"AwaitableHTTPRequest\"!

signal request_finished     ## Emits once the current request finishes, right after [member is_requesting] is set to false.
var is_requesting := false  ## Whether the node is busy performing a request. This variable is read-only.

## Performs an awaitable HTTP request.[br]
## Take a look at the [code]examples.tscn[/code] scene in the addon directory for inspiration![br]
## [br]
## [b]Note:[/b] Header names will be in lowercase, as some web servers prefer this approach and them being case-insensitive as per specification. Therefore, it is good practice to not rely on capitalization.
## [br]
## Here is an example with minimal error-handling:
## [codeblock]
## extends AwaitableHTTPRequest
##
## func _ready() -> void:
##     var resp := await async_request(\"https://api.github.com/users/swarkin\")
##     if resp.success() and resp.status_ok():
##         print(resp.status)                   # 200
##         print(resp.headers[\"content-type\"])  # application/json
##
##         var json := resp.body_as_json()
##         print(json[\"login\"])                 # Swarkin
## [/codeblock]
func AsyncRequestString(url: String, custom_headers := PackedStringArray(), method := HTTPClient.Method.METHOD_GET, request_data := \"\") -> HTTPResult:
	if is_requesting:
		push_warning(\"AwaitableHTTPRequest is busy performing a request.\")
		return HTTPResult._from_error(Error.ERR_BUSY)

	is_requesting = true

	var err := request(url, custom_headers, method, request_data)
	if err:
		return HTTPResult._from_error(err)

	@warning_ignore(\"unsafe_cast\")
	var result := await request_completed as Array
	is_requesting = false
	request_finished.emit()

	return HTTPResult._from_array(result)

func AsyncRequestByteArray(url: String, custom_headers := PackedStringArray(), method := HTTPClient.Method.METHOD_GET, request_data:PackedByteArray=[]):
	if is_requesting:
		push_warning(\"AwaitableHTTPRequest is busy performing a request.\")
		return HTTPResult._from_error(Error.ERR_BUSY)

	is_requesting = true

	var err := request_raw(url, custom_headers, method, request_data)
	if err:
		return HTTPResult._from_error(err)

	@warning_ignore(\"unsafe_cast\")
	var result := await request_completed as Array
	is_requesting = false
	request_finished.emit()

	return HTTPResult._from_array(result)
"

[node name="Press F6 to run examples" type="Node" node_paths=PackedStringArray("http")]
editor_description = "This scene is not required and may be deleted freely."
script = SubResource("GDScript_qphse")
http = NodePath("AwaitableHTTPRequest")

[node name="AwaitableHTTPRequest" type="HTTPRequest" parent="."]
script = SubResource("GDScript_2i6dy")
